GLOBAL { PAGELENGTH 0; };


LABEL { NAME "DAT_0002"; ADDR $0002; };
LABEL { NAME "TEMP_MSB"; ADDR $0004; };
LABEL { NAME "TEMP_LSB"; ADDR $0006; };
LABEL { NAME "TEMP_MSB_0007"; ADDR $0007; };
LABEL { NAME "Binary_value_temp"; ADDR $0032; };
LABEL { NAME "BCD_value_temp"; ADDR $0034; };
LABEL { NAME "TENS_TEMPERATURE"; ADDR $0036; };
LABEL { NAME "UNITS_TEMPERATURE"; ADDR $0037; };
LABEL { NAME "TENTHS_TEMPERATURE"; ADDR $0038; };
LABEL { NAME "Reversed_raw_data"; ADDR $0039; };
LABEL { NAME "Data_Temp_String_for_display_Line3"; ADDR $004d; };
LABEL { NAME "Timer_tick_low"; ADDR $0066; };
LABEL { NAME "Timer_tick_high"; ADDR $0067; };
LABEL { NAME "SCHEDULE_FLAG"; ADDR $0512; };
LABEL { NAME "Device_Response"; ADDR $2000; };
LABEL { NAME "VIA1_PORT_B"; ADDR $8800; };
LABEL { NAME "VIA1_PORT_A"; ADDR $8801; };
LABEL { NAME "VIA1_DDR_B"; ADDR $8802; };
LABEL { NAME "VIA1_DDR_A"; ADDR $8803; };
LABEL { NAME "VIA1_Timer_1_Counter_Low"; ADDR $8804; };
LABEL { NAME "VIA1_Timer_1_Counter_High"; ADDR $8805; };
LABEL { NAME "VIA1_Auxiliary_Control_Register"; ADDR $880b; };
LABEL { NAME "VIA1_Interrupt_Flag_Register"; ADDR $880d; };
LABEL { NAME "VIA1_Interrupt_Enable_Register"; ADDR $880e; };
LABEL { NAME "VIA2_PORT_B"; ADDR $9000; };
LABEL { NAME "VIA2_DDR_B"; ADDR $9002; };
LABEL { NAME "INITIAL_TRANSACTION_SEQUENCE"; ADDR $a000; };
LABEL { NAME "loop"; ADDR $a0f8; COMMENT "Loops twice to build up 2 bytes"; };
LABEL { NAME "ONEWIRE_ReadByte"; ADDR $a104; };
LABEL { NAME "loop_a106"; ADDR $a106; };
LABEL { NAME "ONEWIRE_ReadBitSlot"; ADDR $a119; COMMENT "Loops 8 times by sending read pulse "; };
LABEL { NAME "ONEWIRE_ResetAndWaitPresence"; ADDR $a135; COMMENT "Pin to low"; };
LABEL { NAME "ONEWIRE_WaitPresencePulse"; ADDR $a149; COMMENT " read 1 or 0"; };
LABEL { NAME "ONEWIRE_WriteByte"; ADDR $a152; COMMENT "starting point for loop"; };
LABEL { NAME "loop_until_all_8_digits_transmitted"; ADDR $a154; };
LABEL { NAME "ONEWIRE_WriteBit_FromCarry"; ADDR $a15e; COMMENT "branch on carry clear - write a 0"; };
LABEL { NAME "jump_if_writing_0"; ADDR $a166; };
LABEL { NAME "Exit_out"; ADDR $a169; };
LABEL { NAME "ONEWIRE_SenseDQ_Level"; ADDR $a16a; COMMENT "digital line"; };
LABEL { NAME "Jump_if_not_equal"; ADDR $a179; };
LABEL { NAME "ONEWIRE_WriteBit1"; ADDR $a17f; };
LABEL { NAME "ONEWIRE_WriteBit0"; ADDR $a191; };
LABEL { NAME "DELAY_SHORT"; ADDR $a1ac; COMMENT " "; };
LABEL { NAME "DELAY_LONG"; ADDR $a1b1; };
LABEL { NAME "Loop_decrement_wait_till_0"; ADDR $a1b3; };
LABEL { NAME "wait_done"; ADDR $a1bc; };
LABEL { NAME "LCD_INSTRUCTION"; ADDR $a1bd; };
LABEL { NAME "PRINT_CHARACTER"; ADDR $a1d3; };
LABEL { NAME "LCD_BUSY"; ADDR $a1e9; };
LABEL { NAME "Loop_if_busy"; ADDR $a1ef; };
LABEL { NAME "Line_2_Fixed_data"; ADDR $a20c; };
LABEL { NAME "Line_4_Fixed_data"; ADDR $a213; };
LABEL { NAME "DAT_a21b"; ADDR $a21b; };
LABEL { NAME "DAT_a21c"; ADDR $a21c; };
LABEL { NAME "DAT_a21d"; ADDR $a21d; };
LABEL { NAME "DAT_a21e"; ADDR $a21e; };
LABEL { NAME "Entry_Point_from_RESET"; ADDR $a21f; };
LABEL { NAME "LAB_a262"; ADDR $a262; };
LABEL { NAME "MAIN_BODY"; ADDR $a265; };
LABEL { NAME "CREATE_OUTPUT_STRING_FOR_DISPLAY"; ADDR $a27b; };
LABEL { NAME "CONVERT_TO_CELSIUS"; ADDR $a2bf; COMMENT "only converts from Bit 11 to Bit3 of 2 Byte value"; };
LABEL { NAME "jump_to_next"; ADDR $a2cf; };
LABEL { NAME "jump_to_next_a2db"; ADDR $a2db; };
LABEL { NAME "jump_to_next_a2e7"; ADDR $a2e7; };
LABEL { NAME "jump_to_next_a2f3"; ADDR $a2f3; };
LABEL { NAME "jump_to_next_a2ff"; ADDR $a2ff; };
LABEL { NAME "jump_to_next_a30b"; ADDR $a30b; };
LABEL { NAME "jump_to_next_a317"; ADDR $a317; };
LABEL { NAME "jump_to_next_a324"; ADDR $a324; };
LABEL { NAME "LAB_a328"; ADDR $a328; };
LABEL { NAME "CONVERT_TO_BCD_DECIMAL"; ADDR $a329; COMMENT "set decimal mode flag"; };
LABEL { NAME "Loop"; ADDR $a32f; };
LABEL { NAME "bug_out"; ADDR $a337; };
LABEL { NAME "CONVERT_TO_ASCII"; ADDR $a33b; };
LABEL { NAME "SEND_LONG_PULSE"; ADDR $a350; };
LABEL { NAME "REVERSE_ORDER_OF_BYTES"; ADDR $a363; COMMENT "Read of scratchpad is LSB first, so this function reverses order"; };
LABEL { NAME "LAB_a369"; ADDR $a369; COMMENT "shifts left, so whatever is in bit7 goes into carry flag. This picked up by next function"; };
LABEL { NAME "LAB_a379"; ADDR $a379; };
LABEL { NAME "USE_CARRY_TO_WRITE_1_or_0"; ADDR $a38b; };
LABEL { NAME "LAB_a395"; ADDR $a395; };
LABEL { NAME "LAB_a39a"; ADDR $a39a; };
LABEL { NAME "SORT_OUT_WHAT_TO_PRINT_EACH_LINE"; ADDR $a39b; };
LABEL { NAME "PRINT_LINE_1"; ADDR $a3c8; };
LABEL { NAME "Subroutine"; ADDR $a3ca; };
LABEL { NAME "LAB_a3d5"; ADDR $a3d5; };
LABEL { NAME "PRINT_LINE_2"; ADDR $a3d6; };
LABEL { NAME "loop_a3d8"; ADDR $a3d8; };
LABEL { NAME "Bug_out"; ADDR $a3e4; };
LABEL { NAME "PRINT_LINE_3"; ADDR $a3e5; };
LABEL { NAME "loop_a3e7"; ADDR $a3e7; };
LABEL { NAME "bug_out_a3f2"; ADDR $a3f2; };
LABEL { NAME "PRINT_LINE_4"; ADDR $a3f3; };
LABEL { NAME "loop_a3f5"; ADDR $a3f5; };
LABEL { NAME "bug_out_a401"; ADDR $a401; };
LABEL { NAME "SET_LCD_CURSOR"; ADDR $a402; COMMENT "a register loaded with cursor start byte. Then loops until line with that byte found.Then sends cursor line instruction to LCD"; };
LABEL { NAME "bug_out_a412"; ADDR $a412; };
LABEL { NAME "LAB_a418"; ADDR $a418; };
LABEL { NAME "LAB_a41e"; ADDR $a41e; };
LABEL { NAME "LAB_a424"; ADDR $a424; };
LABEL { NAME "LAB_a42a"; ADDR $a42a; };
LABEL { NAME "LAB_a438"; ADDR $a438; };
LABEL { NAME "Scheduler_Evaluate_Tick"; ADDR $a43a; COMMENT "Disable IRQ while evaluating"; };
LABEL { NAME "BCC_BelowThreshold"; ADDR $a451; COMMENT "timer less than 300"; };
LABEL { NAME "LAB_a456"; ADDR $a456; COMMENT "timer is >300"; };
LABEL { NAME "Reset_hi_lo_to_zero"; ADDR $a458; COMMENT "reset both lo and hi to zero"; };
LABEL { NAME "SET_SCHEDULE_FLAG"; ADDR $a45c; COMMENT "0,1 or 2"; };
LABEL { NAME "VIA1_IRQ_Handler"; ADDR $a462; COMMENT "fires when IR requested by VIA1 Timer"; };
LABEL { NAME "LAB_a470"; ADDR $a470; };
LABEL { NAME "LAB_a488"; ADDR $a488; };
LABEL { NAME "LAB_a489"; ADDR $a489; };
LABEL { NAME "NMI"; ADDR $fffa; };
LABEL { NAME "RES"; ADDR $fffc; };
LABEL { NAME "IRQ"; ADDR $fffe; };

# ---- Data ranges inferred from defined data in Ghidra ----
RANGE { START $0004; END $0004; TYPE BYTETABLE; };
RANGE { START $0006; END $0007; TYPE BYTETABLE; };
RANGE { START $0032; END $0032; TYPE BYTETABLE; };
RANGE { START $0034; END $0034; TYPE BYTETABLE; };
RANGE { START $0036; END $0048; TYPE BYTETABLE; };
RANGE { START $004d; END $0067; TYPE BYTETABLE; };
RANGE { START $0512; END $0512; TYPE BYTETABLE; };
RANGE { START $2000; END $2000; TYPE BYTETABLE; };
RANGE { START $8800; END $8801; TYPE BYTETABLE; };
RANGE { START $a20c; END $a219; TYPE TEXTTABLE; };
RANGE { START $a21b; END $a21e; TYPE BYTETABLE; };
RANGE { START $fffa; END $ffff; TYPE WORDTABLE; };
